diff --git a/src/jconf.c b/src/jconf.c
index 2ddaedc..621803b 100644
--- a/src/jconf.c
+++ b/src/jconf.c
@@ -97,6 +97,40 @@ void parse_addr(const char *str, ss_addr_t *addr)
     }
 }
 
+static int parse_dscp(char *str)
+{
+    size_t str_len = strlen(str);
+
+    // Pre-defined values (EF, CSx, AFxy)
+    if (str_len == 2 && strcasecmp(str, "EF") == 0) {
+        return DSCP_EF;
+    }
+
+    if (str_len == DSCP_CS_LEN && strncasecmp(str, "CS", 2) == 0) {
+        if (str[2] >= '0' && str[2] <= '7') {
+            // CSx = 8x
+            return (str[2] - '0') << 3;
+        }
+    }
+
+    if (str_len == DSCP_AF_LEN && strncasecmp(str, "AF", 2) == 0) {
+        if (str[2] >= '1' && str[2] <= '4' && str[3] >= '1' && str[3] <= '3') {
+            // AFxy = 8x + 2y
+            return ((str[2] - '0') << 3) | ((str[3] - '0') << 1);
+        }
+    }
+
+    // Manual hexadecimal mode (0xYZ)
+    char *endptr;
+    int dscp = (int)strtol(str, &endptr, 0);
+    if (*endptr == '\0' && dscp >= DSCP_MIN && dscp <= DSCP_MAX) {
+        return dscp;
+    }
+
+    LOGE("Invalid DSCP value (%s)", str);
+    return DSCP_DEFAULT;
+}
+
 jconf_t *read_jconf(const char *file)
 {
     static jconf_t conf;
@@ -193,6 +227,23 @@ jconf_t *read_jconf(const char *file)
                 conf.nofile = value->u.integer;
             } else if (strcmp(name, "nameserver") == 0) {
                 conf.nameserver = to_string(value);
+            } else if (strcmp(name, "dscp") == 0) {
+                if (value->type == json_object) {
+                    for (j = 0; j < value->u.object.length; j++) {
+                        if (j >= MAX_DSCP_NUM) {
+                            break;
+                        }
+                        json_value *v = value->u.object.values[j].value;
+                        if (v->type == json_string) {
+                            int dscp = parse_dscp(to_string(v));
+                            char * port = ss_strndup(value->u.object.values[j].name,
+                                        value->u.object.values[j].name_length);
+                            conf.dscp[j].port = atoi(port);
+                            conf.dscp[j].dscp = dscp;
+                            conf.dscp_num = j + 1;
+                        }
+                    }
+                }
             }
         }
     } else {
diff --git a/src/jconf.h b/src/jconf.h
index 752caf4..0621fbe 100644
--- a/src/jconf.h
+++ b/src/jconf.h
@@ -24,11 +24,21 @@
 
 #define MAX_PORT_NUM 1024
 #define MAX_REMOTE_NUM 10
+#define MAX_DSCP_NUM 64
 #define MAX_CONF_SIZE 128 * 1024
 #define MAX_DNS_NUM 4
 #define MAX_CONNECT_TIMEOUT 10
 #define MIN_UDP_TIMEOUT 10
 
+#define DSCP_EF     0x2E
+#define DSCP_MIN    0x0
+#define DSCP_MAX    0x3F
+#define DSCP_DEFAULT 0x0
+#define DSCP_MIN_LEN 2
+#define DSCP_MAX_LEN 4
+#define DSCP_CS_LEN 3
+#define DSCP_AF_LEN 4
+
 typedef struct {
     char *host;
     char *port;
@@ -40,6 +50,11 @@ typedef struct {
 } ss_port_password_t;
 
 typedef struct {
+    unsigned short port;
+    int dscp;
+} ss_dscp_t;
+
+typedef struct {
     int remote_num;
     ss_addr_t remote_addr[MAX_REMOTE_NUM];
     int port_password_num;
@@ -54,6 +69,8 @@ typedef struct {
     int fast_open;
     int nofile;
     char *nameserver;
+    int dscp_num;
+    ss_dscp_t dscp[MAX_DSCP_NUM];
 } jconf_t;
 
 jconf_t *read_jconf(const char *file);
diff --git a/src/redir.c b/src/redir.c
index 3e2bc1b..c77570f 100644
--- a/src/redir.c
+++ b/src/redir.c
@@ -29,6 +29,7 @@
 #include <locale.h>
 #include <netdb.h>
 #include <netinet/in.h>
+#include <netinet/ip.h>
 #include <netinet/tcp.h>
 #include <pthread.h>
 #include <signal.h>
@@ -607,9 +608,56 @@ static void accept_cb(EV_P_ ev_io *w, int revents)
     setsockopt(remotefd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
 #endif
 
-    // Setup
     setnonblocking(remotefd);
 
+    // Logging (client address and original destination)
+    char ip[2][NI_MAXHOST];
+    char port[2][NI_MAXSERV];
+
+    err = getnameinfo(remote_addr, sizeof(*remote_addr),
+            ip[0], sizeof(ip[0]), port[0], sizeof(port[0]),
+            NI_NUMERICHOST | NI_NUMERICSERV);
+    if (err) {
+        LOGE("getnameinfo: %s", gai_strerror(err));
+    }
+    else {
+        err = getnameinfo((struct sockaddr *)&destaddr, sizeof(destaddr),
+                ip[1], sizeof(ip[1]), port[1], sizeof(port[1]),
+                NI_NUMERICHOST | NI_NUMERICSERV);
+        if (err) {
+            LOGE("getnameinfo: %s", gai_strerror(err));
+        }
+        else {
+            LOGI("accept client %s:%s (-> %s:%s)", ip[0], port[0], ip[1], port[1]);
+        }
+    }
+
+    // Set DSCP
+    int dest_port;
+    switch (destaddr.ss_family) {
+        case AF_INET:
+            dest_port = ntohs(((struct sockaddr_in *)&destaddr)->sin_port);
+            break;
+        case AF_INET6:
+            dest_port = ntohs(((struct sockaddr_in6 *)&destaddr)->sin6_port);
+            break;
+        default:
+            LOGE("An unexpected error occurred.");
+            return;
+    }
+
+    for (int j = 0; j < listener->dscp_num; j++) {
+        if (listener->dscp[j].port == dest_port) {
+            int tos = listener->dscp[j].dscp << 2;
+            err = setsockopt(remotefd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
+            if (err) {
+                ERROR("setsockopt IP_TOS");
+            }
+            break;
+        }
+    }
+
+
     server_t *server = new_server(serverfd, listener->method);
     remote_t *remote = new_remote(remotefd, listener->timeout);
     server->remote   = remote;
@@ -640,6 +688,9 @@ int main(int argc, char **argv)
     ss_addr_t remote_addr[MAX_REMOTE_NUM];
     char *remote_port = NULL;
 
+    int dscp_num = 0;
+    ss_dscp_t * dscp = NULL;
+
     opterr = 0;
 
     while ((c = getopt(argc, argv, "f:s:p:l:k:t:m:c:b:a:n:uUvA")) != -1)
@@ -736,6 +787,8 @@ int main(int argc, char **argv)
         if (auth == 0) {
             auth = conf->auth;
         }
+        dscp_num = conf->dscp_num;
+        dscp = conf->dscp;
 #ifdef HAVE_SETRLIMIT
         if (nofile == 0) {
             nofile = conf->nofile;
@@ -802,6 +855,9 @@ int main(int argc, char **argv)
     listen_ctx.timeout = atoi(timeout);
     listen_ctx.method  = m;
 
+    listen_ctx.dscp_num = dscp_num;
+    listen_ctx.dscp = dscp;
+
     struct ev_loop *loop = EV_DEFAULT;
 
     if (mode != UDP_ONLY) {
diff --git a/src/redir.h b/src/redir.h
index 30d7d60..7c67198 100644
--- a/src/redir.h
+++ b/src/redir.h
@@ -34,6 +34,8 @@ typedef struct listen_ctx {
     int fd;
     int method;
     struct sockaddr **remote_addr;
+    int dscp_num;
+    ss_dscp_t *dscp;
 } listen_ctx_t;
 
 typedef struct server_ctx {
