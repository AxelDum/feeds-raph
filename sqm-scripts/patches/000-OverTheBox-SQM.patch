diff --git a/luci/sqm-cbi.lua b/luci/sqm-cbi.lua
index 9b8af51..fd5dd53 100644
--- a/luci/sqm-cbi.lua
+++ b/luci/sqm-cbi.lua
@@ -13,6 +13,7 @@ You may obtain a copy of the License at
 $Id$
 ]]--
 
+local uci = luci.model.uci.cursor()
 local wa = require "luci.tools.webadmin"
 local fs = require "nixio.fs"
 local net = require "luci.model.network".init()
@@ -55,17 +56,48 @@ function e.write(self, section, value)
 	end
 	return Flag.write(self, section, value)
 end
--- TODO: inform the user what we just did...
 
-n = s:taboption("tab_basic", ListValue, "interface", translate("Interface name"))
+-- TODO: inform the user what we just did...
+n = s:taboption("tab_basic", ListValue, "_interface_all", translate("Interface name"))
 -- sm lifted from luci-app-wol, the original implementation failed to show pppoe-ge00 type interface names
 for _, iface in ipairs(ifaces) do
 	if not (iface == "lo" or iface:match("^ifb.*")) then
-		n:value(iface)
+		local multipath = uci:get("network", iface, "multipath")
+		if multipath == "on" or multipath == "backup" or multipath == "master" or multipath == "handover" then
+			n:value(iface, (uci:get("network", iface, "label") or "") .. " (" .. iface .. ")" )
+		else
+			n:value(iface)
+		end
 	end
 end
 n.rmempty = false
+n.write = function(self, section, value)
+	m:set(section, "interface", value)
+end
+n.cfgvalue = function(self, section)
+	return m:get(section, "interface", value)
+end
+n.optional = true
 
+-- TODO: inform the user what we just did...
+n1 = s:taboption("tab_basic", ListValue, "_interface_mptcp", translate("Interface name"))
+-- sm lifted from luci-app-wol, the original implementation failed to show pppoe-ge00 type interface names
+for _, iface in ipairs(ifaces) do
+	if not (iface == "lo" or iface:match("^ifb.*")) then
+		local multipath = uci:get("network", iface, "multipath")
+		if multipath == "on" or multipath == "backup" or multipath == "master" or multipath == "handover" then
+			n1:value(iface, (uci:get("network", iface, "label") or "") .. " (" .. iface .. ")" )
+		end
+	end
+end
+n1.rmempty = false
+n1.write = function(self, section, value)
+		m:set(section, "interface", value)
+end
+n1.cfgvalue = function(self, section)
+	return m:get(section, "interface", value)
+end
+n1.optional = true
 
 dl = s:taboption("tab_basic", Value, "download", translate("Download speed (kbit/s) (ingress) set to 0 to selectively disable ingress shaping:"))
 dl.datatype = "and(uinteger,min(0))"
@@ -86,23 +118,26 @@ if fs.stat(run_path) then
 		c:value( file )
 	end
 end
-c.default = "fq_codel"
+c.default = "sfq"
 c.rmempty = false
 
-
-
 local qos_desc = ""
 sc = s:taboption("tab_qdisc", ListValue, "script", translate("Queue setup script"))
 for file in fs.dir(path) do
 	if string.find(file, ".qos$") then
 		sc:value(file)
+		if file:find("otb") then
+			n1:depends("script", file)
+		else
+			n:depends("script", file)
+		end
 	end
 	if string.find(file, ".qos.help$") then
 		fh = io.open(path .. "/" .. file, "r")
 		qos_desc = qos_desc .. "<p><b>" .. file:gsub(".help$", "") .. ":</b><br />" .. fh:read("*a") .. "</p>"
 	end
 end
-sc.default = "simple.qos"
+sc.default = "otb.qos"
 sc.rmempty = false
 sc.description = qos_desc
 
@@ -182,11 +217,11 @@ ll = s:taboption("tab_linklayer", ListValue, "linklayer", translate("Which link
 ll:value("none", "none ("..translate("default")..")")
 ll:value("ethernet", "Ethernet with overhead: select for e.g. VDSL2.")
 ll:value("atm", "ATM: select for e.g. ADSL1, ADSL2, ADSL2+.")
-ll.default = "none"
+ll.default = "atm"
 
 po = s:taboption("tab_linklayer", Value, "overhead", translate("Per Packet Overhead (byte):"))
 po.datatype = "and(integer,min(-1500))"
-po.default = 0
+po.default = 44
 po.isnumber = true
 po.rmempty = true
 po:depends("linklayer", "ethernet")
diff --git a/platform/openwrt/sqm-uci b/platform/openwrt/sqm-uci
index 13a7a0b..82372e5 100644
--- a/platform/openwrt/sqm-uci
+++ b/platform/openwrt/sqm-uci
@@ -1,16 +1,11 @@
 
-config queue 'eth1'
-        option enabled '0'
-        option interface 'eth1'
-        option download '85000'
-        option upload '10000'
-        option qdisc 'fq_codel'
-        option script 'simple.qos'
-        option qdisc_advanced '0'
-        option ingress_ecn 'ECN'
-        option egress_ecn 'ECN'
-        option qdisc_really_really_advanced '0'
-        option itarget 'auto'
-        option etarget 'auto'
-        option linklayer 'none'
+config queue
+	option enabled '0'
+	option qdisc 'sfq'
+	option script 'otb.qos'
+	option linklayer 'atm'
+	option overhead '44'
+	option download '0'
+	option upload '1000'
+	option qdisc_advanced '0'

diff --git a/src/otb.qos b/src/otb.qos
new file mode 100644
index 0000000..2384ace
--- /dev/null
+++ b/src/otb.qos
@@ -0,0 +1,152 @@
+#!/bin/sh
+
+# This script implements a 3 queue traffic classification system on egress and
+# single queue on ingress. It is built specifically for NAT/Masquerade gateways.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+
+. ${SQM_LIB_DIR}/defaults.sh
+
+
+
+egress() {
+
+
+    TUN0_PORT=$(uci -q get vtund.tunnel.port || echo "5005")
+    XTUN0_PORT=$(uci -q get vtund.Xtun0.port || echo "5008")
+    SOCKS_PORT=$(uci -q get shadowsocks.proxy.port || echo "1090")
+
+    ipt -t mangle -F QOS_MARK_${IFACE}
+    ipt -t mangle -X QOS_MARK_${IFACE}
+    ipt -t mangle -N QOS_MARK_${IFACE}
+
+    ipt -t mangle -F QOS_RULES_${IFACE}
+    ipt -t mangle -X QOS_RULES_${IFACE}
+    ipt -t mangle -N QOS_RULES_${IFACE}
+
+    ipt -t mangle -A OUTPUT -o ${IFACE} -g QOS_MARK_${IFACE}
+    ipt -t mangle -A QOS_MARK_${IFACE} -j CONNMARK --restore-mark --nfmask ${IPT_MASK} --ctmask ${IPT_MASK}
+    ipt -t mangle -A QOS_MARK_${IFACE} -m mark --mark 0x00${IPT_MASK_STRING} -j QOS_RULES_${IFACE}
+    
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m length --length :512  -j MARK --set-mark 0x02${IPT_MASK_STRING}
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m length --length 512:  -j MARK --set-mark 0x03${IPT_MASK_STRING}
+
+
+
+    #PRIORITY traffic is guaranteed 30% of the bandwidth and capped to max 30%.
+    PRIO=$(( ${UPLINK} * 30 / 100 ))
+    #NORMAL is given a link share target of 50% without guarantee resulting in
+    #a 2.5:1 bandwidth allocation vs BULK which is given a target of 20%.
+    #Starvation is avoided by capping the PRIORITY queue. HFSC corner cases are
+    #mitigated by using the same LS+RT curve on PRIORITY.
+    NORMAL=$(( ${UPLINK} * 50 / 100 ))
+    BULK=$(( ${UPLINK} * 20 / 100 ))
+
+
+    $TC qdisc del dev ${IFACE} root 2> /dev/null
+    $TC qdisc add dev ${IFACE} root handle 1: `get_stab_string` hfsc default 13
+
+    $TC class add dev ${IFACE} parent 1: classid 1:1 hfsc sc rate ${UPLINK}kbit \
+    ul rate ${UPLINK}kbit
+
+    $TC class add dev ${IFACE} parent 1:1 classid 1:11 hfsc sc rate ${PRIO}kbit \
+    ul rate ${NORMAL}kbit
+    $TC class add dev ${IFACE} parent 1:1 classid 1:12 hfsc ls rate ${NORMAL}kbit
+    $TC class add dev ${IFACE} parent 1:1 classid 1:13 hfsc ls rate ${BULK}kbit
+
+    $TC qdisc add dev ${IFACE} parent 1:11 handle 110: ${QDISC} \
+    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
+    `get_quantum  300` `get_flows ${PRIO}` ${EQDISC_OPTS}
+    $TC qdisc add dev ${IFACE} parent 1:12 handle 120: ${QDISC} \
+    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
+    `get_quantum  300` `get_flows ${NORMAL}` ${EQDISC_OPTS}
+    $TC qdisc add dev ${IFACE} parent 1:13 handle 130: ${QDISC} \
+    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
+    `get_quantum  300` `get_flows ${BULK}` ${EQDISC_OPTS}
+
+    #FLOW qdisc ensures that on Xfq_codel flows are taking pre-nat informations.
+    $TC filter add dev ${IFACE} parent 110: handle 110 protocol all flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst divisor `get_flows_count ${PRIO}`
+    $TC filter add dev ${IFACE} parent 120: handle 120 protocol all flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst divisor `get_flows_count ${NORMAL}`
+    $TC filter add dev ${IFACE} parent 130: handle 130 protocol all flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst divisor `get_flows_count ${BULK}`
+
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 1 u32 match ip dport ${XTUN0_PORT} 0xffff  flowid 1:11
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 1 u32 match ip dport ${TUN0_PORT} 0xffff  flowid 1:12
+#    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 1 u32 match ip dport ${SOCKS_PORT} 0xffff  flowid 1:13
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 match mark 0x02 ${IPT_MASK} flowid 1:12
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 match mark 0x03 ${IPT_MASK} flowid 1:13
+
+}
+
+ingress() {
+
+    $TC qdisc del dev ${IFACE} handle ffff: ingress 2> /dev/null
+    $TC qdisc add dev ${IFACE} handle ffff: ingress
+
+    $TC qdisc del dev ${DEV} root 2> /dev/null
+    $TC qdisc add dev ${DEV} root handle 1: `get_stab_string` hfsc default 1
+
+    #Use a single queue for ingress.
+    $TC class add dev ${DEV} parent 1: classid 1:1 hfsc sc rate ${DOWNLINK}kbit ul rate ${DOWNLINK}kbit
+
+    $TC qdisc add dev ${DEV} parent 1:1 handle 11: ${QDISC} `get_limit ${ILIMIT}` `get_target "${ITARGET}" ${DOWNLINK}` `get_ecn ${IECN}` `get_quantum  1540` `get_flows ${DOWNLINK}` ${IQDISC_OPTS}
+
+    $TC filter add dev ${DEV} parent 11: handle 11 protocol all flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst  divisor `get_flows_count ${DOWNLINK}`
+
+
+    $IP link set dev ${DEV} up
+
+    $TC filter add dev ${IFACE} parent ffff: protocol all prio 1 u32 match u32 0 0 action mirred egress redirect dev ${DEV}
+
+}
+
+sqm_start() {
+    [ -n "${IFACE}" ] || return 1
+    [ -z "$DEV" ] && DEV=$( get_ifb_for_if ${IFACE} )
+    do_modules
+    verify_qdisc "hfsc" || return 1
+    verify_qdisc ${QDISC} || return 1
+    sqm_logger "Starting ${SCRIPT}"
+
+    eth_setup
+    #ipt_setup
+
+    if [ "${UPLINK}" -ne 0 ];
+    then
+        egress
+        sqm_logger "egress shaping activated"
+    else
+        sqm_logger "egress shaping deactivated"
+        $TC qdisc del dev ${IFACE} root 2> /dev/null
+    fi
+    if [ "${DOWNLINK}" -ne 0 ];
+    then
+        verify_qdisc ingress "ingress" || return 1
+        ingress
+        sqm_logger "ingress shaping activated"
+    else
+        sqm_logger "ingress shaping deactivated"
+        $TC qdisc del dev ${DEV} root 2> /dev/null
+        $TC qdisc del dev ${IFACE} ingress 2> /dev/null
+    fi
+
+    return 0
+}
+
+sqm_stop() {
+    $TC qdisc del dev ${IFACE} ingress 2> /dev/null
+    $TC qdisc del dev ${IFACE} root 2> /dev/null
+    [ -n "$CUR_IFB" ] && $TC qdisc del dev ${CUR_IFB} root 2> /dev/null
+    [ -n "$CUR_IFB" ] && sqm_logger "${0}: ${CUR_IFB} shaper deleted"
+
+
+    ipt -t mangle -D POSTROUTING -o ${IFACE} -g QOS_MARK_${IFACE}
+    ipt -t mangle -F QOS_MARK_${IFACE}
+    ipt -t mangle -X QOS_MARK_${IFACE}
+    ipt -t mangle -F QOS_RULES_${IFACE}
+    ipt -t mangle -X QOS_RULES_${IFACE}  [ -n "$CUR_IFB" ] && $IP link set dev ${CUR_IFB} down
+    
+    [ -n "$CUR_IFB" ] && $IP link delete ${CUR_IFB} type ifb
+    [ -n "$CUR_IFB" ] && sqm_logger "${0}: ${CUR_IFB} interface deleted"
+}
