#!/bin/sh
# shellcheck disable=SC1090,SC1091,SC1066,SC1087,SC2086,SC2016
# vim: set noexpandtab tabstop=4 shiftwidth=4 softtabstop=4:
acs_url=192.168.100.10:8080
acs_hash_path=/tmp/acs_hash

. /lib/overthebox

_call_acs() {
	curl -s -m 10 --fail "$acs_url/device/$OTB_DEVICE_ID/$1"
}

_check_connect_acs() {
	uci_path="$1"

	if [ -z "$(uci changes)" ]; then
		return 0
	fi

	if ! curl -s -m 10 --fail "$acs_url/ping" > /dev/null; then
		echo "New conf is breaking network, reversing"
		uci revert "$(echo "$uci_path" | cut -d" " -f1)"
		return 1
	fi
}

_check_hash() {
	uci_path="$1"
	conf="$2"

	escaped_path="$(printf "%s" "$uci_path" | sed 's/[.[\*^$()+?{|]/\\&/g')"

	touch "$acs_hash_path"

	rhash="$(echo "$conf" | md5sum | cut -d" " -f1)"
	lhash="$(grep "$escaped_path" "$acs_hash_path" | cut -d";" -f2)"

	if [ "$rhash" = "$lhash" ]; then
		return 1
	fi

	# Remove the hash if exists
	tmp_file="$(mktemp)"
	awk "!/$escaped_path/{print}" "$acs_hash_path" > "$tmp_file"
	mv "$tmp_file" "$acs_hash_path"

	echo "$uci_path;$rhash" >> "$acs_hash_path"
}

# TODO: Rewrite the json to ensure that we only keep the good fields
_set_conf_firewall_rules() {
	conf="$1"

	echo "$conf"

	_set_conf_array "$conf" "firewall.@rule"
}

# TODO: Rewrite the json to ensure that we only keep the good fields
_set_conf_firewall_redirects() {
	conf="$1"

	_set_conf_array "$conf" "firewall.@redirect"
}

# TODO: Rewrite the json to ensure that we only keep the good fields
_set_conf_dhcp_staticleases() {
	conf="$1"

	_set_conf_array "$conf" "dhcp.@host"
}

# Takes an input as { "key": "value" } and apply it as an uci configuration on uci_path as "set uci_path.key=value"
_set_conf_single_static() {
	conf="$1"
	uci_path="$2"
	conf_type="$3"

	# Check hash
	if ! _check_hash "$uci_path" "$ret"; then
		echo "hash is the same (static)"
		return 1
	fi

	# Map key to value
	uci set "$uci_path=$conf_type"
	echo "$conf" | jq -r --arg ucipath "$uci_path"  'to_entries | .[] | @text "set \($ucipath).\(.key)=\"\(.value)\""' | uci -q batch

	# No need to delete rules as they are deleted if set to ""
}

_add_prefix_entries() {
	entries="$1"
	prefix="$2"

	echo "$entries" | jq --arg prefix "$prefix" 'to_entries |  map({($prefix + .key): (.value)}) | add'
}

_apply_remote_conf() {
	url="$1"

	# Get conf JSON
	ret="$(_call_acs "$url")" || {
		echo "Failed to retrieve remote conf"
		return 1
	}

	# TODO: Do something better than this
	if [ "$url" = "dhcp/staticleases" ]; then
		_set_conf_dhcp_staticleases "$ret"

	elif [ "$url" = "firewall/rules" ]; then
		_set_conf_firewall_rules "$ret"

	elif [ "$url" = "firewall/redirects" ]; then
		_set_conf_firewall_redirects "$ret"

	elif [ "$url" = "network/interfaces" ]; then
		_set_conf_network_interface "$ret"

	elif [ "$url" = "network/routes6" ]; then
		_set_conf_network_routes6 "$ret"

	elif [ "$url" = "glorytun/tun" ]; then
		_set_conf_glorytun "$ret"

	elif [ "$url" = "dhcp/configs" ]; then
		_set_conf_dhcp_config "$ret"

	elif [ "$url" = "dns/nameservers" ]; then
		_set_conf_dns_nameserver "$ret"

	else
		echo "Missing conf type"
	fi

	_check_connect_acs "$uci_path" || return

	uci commit
}

_set_conf_network_interface() {
	conf="$1"

	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		ifname="$(echo "$sconf" | jq -r ".ifname")"
		_set_conf_single_static "$sconf" "network.$ifname" "interface"
	done
}

_set_conf_network_routes6() {
	conf="$1"

	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		name="$(echo "$sconf" | jq -r ".name")"
		sconf="$(echo "$sconf" | jq -r '{
			"interface": "\(.interface)",
			"target":    "\(.target)",
			"netmask":   "\(.netmask)",
			"gateway":   "\(.gateway)",
			"metric":    "\(.metric)",
			"mtu":       "\(.mtu)",
			"table":     "\(.table)",
			"source":    "\(.source)",
			"onlink":    "\(.onlink)",
			"type":      "\(.type)",
		}')"

		_set_conf_single_static	"$sconf" "network.$name" "route6"
	done
}

_set_conf_glorytun() {
	conf="$1"
	sconf="$(echo $conf | jq -r '{
		"dev": "\(.dev_name)",
		"server": "\(.server)",
		"port": "\(.port)",
		"key": "\(.key)",
		"id": "\(.id)",
		"enable": 1
	}')"

	dev_name="$(echo $conf | jq -r  '.dev_name')"

	_set_conf_single_static "$sconf" "glorytun.$dev_name" "mud"
}

_set_conf_dhcp_config() {
	conf="$1"

	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		ifname="$(echo $sconf | jq -r '.ifname')"
		tconf="$(echo $sconf | jq -r '{
			"interface": "\(.ifname)",
			"start": "\(.start)",
			"limit": "\(.end)",
			"leasetime": "\(.lease_time)",
			"force": 1,
			"ra": 1
		}')"

		_set_conf_single_static "$tconf" "dhcp.$ifname" "dhcp"
	done
}

_set_conf_dns_nameserver() {
	conf="$1"

	# Change .address to .server
	sconf="$(echo "$conf" | jq -r '[.[].address]')"

	_set_conf_list "$sconf" "dhcp.@dnsmasq[0].server"
	echo "OK"
}

# Converts an array element to a constant name
# Eg: dhcp.@dnsmasq[-1] -> dhcp.cfg01411c
_find_rule_const_name() {
	uci show "$1" | cut -d"=" -f1 | head -n1
}

_find_rule_index() {
	rule="$1"
	conf_id="$2"

	found=false
	i=0
	id=
	while true; do
		uci show "$rule[$i]" > /dev/null 2>&1 || break
		id="$(uci get "$rule[$i].id" 2>/dev/null || true)"
		if [ "$id" = "$conf_id" ]; then
			found=true
			break
		fi
		i=$((i+1))
	done

	if [ "$found" = false ]; then
		echo "-1"
	else
		echo "$i"
	fi
}

# _set_conf_list sets conf as uci list
# conf: array of values eg: [ "value1", "value2" ]
# path: path of the list eg: dhcp.@dnsmasq[0].server
_set_conf_list() {
	conf="$1"
	uci_path="$2"

	echo "$uci_path"
	if ! _check_hash "$uci_path" "$conf"; then
		return 1
	fi

	# Delete the list before adding values
	uci set "$uci_path="

	echo "$conf" | jq -r '.[]' | while read -r value; do
		echo uci add_list "$uci_path=$value"
		uci add_list "$uci_path=$value"
	done
}

# _set_conf_array sets conf in an array TODO: Improve this, seems a bit too hacky
_set_conf_array() {
	conf="$1"

	# Is of shape: firewall.@rule
	uci_path_array="$2"

	# Convert to firewall.rule
	uci_path="$(echo $uci_path_array | sed 's/\@//g')"

	# Convert to firewall rule
	uci_cmd="$(echo $uci_path | sed -n -r  's/(^[a-z]*)(\.)/\1 /p')"

	# Check hash
	if ! _check_hash "$uci_path" "$ret"; then
		echo "hash is the same"
		return 1
	fi

	# Set the new rules
	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		conf_id="$(echo "$sconf" | jq -r .id )"
		i="$(_find_rule_index "$uci_path_array" "$conf_id")"

		if [ "$i" -eq "-1" ]; then
			echo "Rule does not exist, creating"

			# Intentional word splitting
			uci add $uci_cmd > /dev/null
		fi

		# Map key to value
		echo "$sconf" | jq -r --arg index "$i" --arg ucipath "$uci_path_array"  'to_entries | .[] | @text "set \($ucipath)[\($index)].\(.key)=\"\(.value)\""' | uci -q batch
	done

	# Delete undefined rules
	i=0
	while true; do
		# We finished iterating over all rules
		uci show "$uci_path_array[$i]" > /dev/null 2>&1 || break

		# If no id is defined, it's should not be there (system rule)
		id=$(uci get "$uci_path_array[$i].id" 2> /dev/null)
		if [ -z "$id" ]; then
			uci delete "$uci_path[$i]"
			continue
		fi

		# Check if id is still present in remote config
		if ! echo "$ret" | jq -e -r --arg id "$id" '[.[].id] | index("\($id)")' > /dev/null; then
			uci delete "$uci_path_array[$i]"
			continue
		fi

		i=$((i+1))
	done
}

_run() {
	otb_reload
	export OTB_DEVICE_ID="a5def614-0f23-4c17-a72b-f8d7704ce070"

	#_apply_remote_conf  "firewall/rules"
	#_apply_remote_conf  "dhcp/staticleases"
	#_apply_remote_conf  "firewall/redirects"
	#_apply_remote_conf  "glorytun/tun"
	#_apply_remote_conf  "network/interfaces"
	#_apply_remote_conf  "dhcp/configs"
	#_apply_remote_conf  "dns/nameservers"
	#_apply_remote_conf  "network/routes6"
}

RUNNING=1
trap 'RUNNING=' INT QUIT TERM

while [ "$RUNNING" ]; do
	#clear
	_run
	sleep 1
done
