#!/bin/sh
# shellcheck disable=SC1090,SC1091,SC1066,SC1087,SC2086
# vim: set noexpandtab tabstop=4 shiftwidth=4 softtabstop=4 :
acs_url=192.168.100.10:8080
#set -e
#set -x

. /lib/overthebox

_call_acs() {
	curl -s -m 10 --fail "$acs_url/device/$OTB_DEVICE_ID/$1"
}

_check_connect_acs() {
	uci_path="$1"

	if [ -z "$(uci changes)" ]; then
		return 0
	fi

	if ! curl -s -m 10 --fail "$acs_url/ping" > /dev/null; then
		echo "New conf is breaking network, reversing"
		uci revert "$(echo "$uci_path" | cut -d" " -f1)"
		return 1
	fi
}

_check_hash() {
	uci_path="$1"
	conf="$2"

	# If it's an array, remote the @
	hash_path="$(echo $uci_path | sed 's/\@//g')""_hash"

	# Check if conf has already been applied
	rhash="$(echo "$conf" | md5sum | cut -d" " -f1)"
	lhash="$(uci get "$hash_path" 2> /dev/null)"

	if [ "$rhash" = "$lhash" ]; then
		return 1
	fi

	uci set "$hash_path=$rhash"
	uci commit "$hash_path"
	return 0
}

# Same as set_conf_static, but append $suffix_name in front of all keys
_set_conf_single_dynamic() {
	conf="$1"
	uci_path="$2"
	conf_type="$3"
	suffix="$4"

	echo "Iterating conf"
	echo "$conf"

	echo "$conf" | jq -r -c '.[]' | while read -r sconf; do
		_set_conf_single_static "$sconf" "$uci_path.$suffix" "$conf_type"
	done

	echo "Done on single_dynamic"
}

# Takes an input as { "key": "value" } and apply it as an uci configuration on uci_path as "set uci_path.key=value"
_set_conf_single_static() {
	conf="$1"
	uci_path="$2"
	conf_type="$3"

	# Check hash
	if false &&  ! _check_hash "$uci_path" "$ret"; then
		echo "hash is the same (static)"
		return 1
	fi

	# Map key to value
	uci set "$uci_path=$conf_type"
	echo "$conf" | jq -r --arg ucipath "$uci_path"  'to_entries | .[] | @text "set \($ucipath).\(.key)=\"\(.value)\""' | uci -q batch

	# No need to delete rules as they are deleted if set to ""
}

_add_prefix_entries() {
	entries="$1"
	prefix="$2"

	echo "$entries" | jq --arg prefix "$prefix" 'to_entries |  map({($prefix + .key): (.value)}) | add'
}

_apply_remote_conf() {
	uci_path="$1"
	url="$2"
	conf_type="$3"

	# Get conf JSON
	ret="$(_call_acs "$url")" || {
		echo "Failed to retrieve remote conf"
		return 1
	}

	# TODO: Do something better than this
	if [ "$conf_type" = "array" ]; then
		_set_conf_array "$ret" "$uci_path"

	elif [ "$conf_type" = "network.interfaces" ]; then
		_set_conf_network_interface "$ret"

	elif [ "$conf_type" = "glorytun" ]; then
		_set_conf_glorytun "$ret"

	elif [ "$conf_type" = "dhcp.configs" ]; then
		_set_conf_dhcp_config "$ret"

	else
		echo "Missing conf type"
	fi

	_check_connect_acs "$uci_path" || return

	uci commit
}

_get_param() {
	echo "$1" | jq -r "$2"
}

_set_conf_network_interface() {
	conf="$1"

	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		ifname="$(_get_param "$sconf" ".ifname")"
		echo ifname is $ifname
		echo "Setting in dynamic : $sconf"
		_set_conf_single_static "$sconf" "network.$ifname" "interface"
	done
}

_set_conf_glorytun() {
	conf="$1"
	sconf="$(echo $conf | jq -r '{
		"dev": "\(.dev_name)",
		"server": "\(.server)",
		"port": "\(.port)",
		"key": "\(.key)",
		"id": "\(.id)",
		"enable": 1
	}')"

	dev_name="$(echo $conf | jq -r  '.dev_name')"

	_set_conf_single_static "$sconf" "glorytun.$dev_name" "mud"
}

_set_conf_dhcp_config() {
	conf="$1"

	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		ifname="$(echo $sconf | jq -r '.ifname')"
		tconf="$(echo $sconf | jq -r '{
			"interface": "\(.ifname)",
			"start": "\(.start)",
			"limit": "\(.end)",
			"leasetime": "\(.lease_time)",
			"force": 1,
			"ra": 1
		}')"

		_set_conf_single_static "$tconf" "dhcp.$ifname" "dhcp"
	done
}

_find_rule_index() {
	rule="$1"
	conf_id="$2"

	found=false
	i=0
	id=
	while true; do
		uci show "$rule[$i]" > /dev/null 2>&1 || break
		id="$(uci get "$rule[$i].id" 2>/dev/null || true)"
		if [ "$id" = "$conf_id" ]; then
			found=true
			break
		fi
		i=$((i+1))
	done

	if [ "$found" = false ]; then
		echo "-1"
	else
		echo "$i"
	fi
}

_set_conf_array() {
	conf="$1"

	# Is of shape: firewall.@rule
	uci_path_array="$2"

	# Convert to firewall.rule
	uci_path="$(echo $uci_path_array | sed 's/\@//g')"

	# Convert to firewall rule
	uci_cmd="$(echo $uci_path | sed -n -r  's/(^[a-z]*)(\.)/\1 /p')"

	# Check hash
	if ! _check_hash "$uci_path" "$ret"; then
		echo "hash is the same"
		return 1
	fi

	# Set the new rules
	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		conf_id="$(echo "$sconf" | jq -r .id )"
		i="$(_find_rule_index "$uci_path_array" "$conf_id")"

		if [ "$i" -eq "-1" ]; then
			echo "Rule does not exist, creating"

			# Intentional word splitting
			uci add $uci_cmd > /dev/null
		fi

		# Map key to value
		echo "$sconf" | jq -r --arg index "$i" --arg ucipath "$uci_path_array"  'to_entries | .[] | @text "set \($ucipath)[\($index)].\(.key)=\"\(.value)\""' | uci -q batch
	done

	# Delete undefined rules
	i=0
	while true; do
		# We finished iterating over all rules
		uci show "$uci_path_array[$i]" > /dev/null 2>&1 || break

		# If no id is defined, it's should not be there (system rule)
		id=$(uci get "$uci_path_array[$i].id" 2> /dev/null)
		if [ -z "$id" ]; then
			uci delete "$uci_path[$i]"
			continue
		fi

		# Check if id is still present in remote config
		if ! echo "$ret" | jq -e -r --arg id "$id" '[.[].id] | index("\($id)")' > /dev/null; then
			uci delete "$uci_path_array[$i]"
			continue
		fi

		i=$((i+1))
	done
}

_run() {
	otb_reload
	export OTB_DEVICE_ID="a5def614-0f23-4c17-a72b-f8d7704ce070"

	#_apply_remote_conf "firewall.@rule" "firewall/rules" "array"
	#_apply_remote_conf "dhcp.@host" "dhcp/staticleases" "array"
	#_apply_remote_conf "firewall.@redirect" "firewall/redirects" "array"
	#_apply_remote_conf "glorytun" "glorytun/tun" "glorytun" "dev_name"

	#_apply_remote_conf "network" "network/interfaces" "network.interfaces" "dev_name"
	#_apply_remote_conf "dhcp" "dhcp/configs" "dhcp.configs"
}

RUNNING=1
trap 'RUNNING=' INT QUIT TERM

while [ "$RUNNING" ]; do
	clear
	_run
	sleep 1
done
